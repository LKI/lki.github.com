<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.81.0" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="Lirian Su" />
  <meta property="og:url" content="https://liriansu.com/posts/2020-07-12-adult-life-code/" />
  <link rel="canonical" href="https://liriansu.com/posts/2020-07-12-adult-life-code/" /><script type="application/ld+json">
  {
      "@context" : "https://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/liriansu.com\/"
      },
      "articleSection" : "posts",
      "name" : "毕业五年的报告之技术",
      "headline" : "毕业五年的报告之技术",
      "description" : "\u003cp\u003e16年接触了 Web 整套技术栈的我，\u003cbr \/\u003e\n决定在这条路上不断攀爬，\u003cbr \/\u003e\n直到找到我技术上的天花板。\u003cbr \/\u003e\n当时我写了一篇\u003ca href=\u0022\/backend-skill-tree\u0022\u003e《后端工程师技能树》\u003c\/a\u003e。\u003c\/p\u003e",
      "inLanguage" : "en-US",
      "author" : "Lirian Su",
      "creator" : "Lirian Su",
      "publisher": "Lirian Su",
      "accountablePerson" : "Lirian Su",
      "copyrightHolder" : "Lirian Su",
      "copyrightYear" : "2020",
      "datePublished": "2020-07-12 23:45:58 \u002b0800 CST",
      "dateModified" : "2020-07-12 23:45:58 \u002b0800 CST",
      "url" : "https:\/\/liriansu.com\/posts\/2020-07-12-adult-life-code\/",
      "keywords" : [  ]
  }
</script>
<title>毕业五年的报告之技术 - 浮云计算</title>
  <meta property="og:title" content="毕业五年的报告之技术 - 浮云计算" />
  <meta property="og:type" content="article" />
  <meta name="description" content="16年接触了 Web 整套技术栈的我，
决定在这条路上不断攀爬，
直到找到我技术上的天花板。
当时我写了一篇《后端工程师技能树》。" />

  <link rel="stylesheet" href="/css/flexboxgrid-6.3.1.min.css" />
  <link rel="stylesheet"
    href="/css/github-markdown.min.css" />
  <link rel="stylesheet" href="/css/highlight/tomorrow.min.css" />
  <link rel="stylesheet" href="/css/index.css">
  <link href="/index.xml" rel="alternate" type="application/rss+xml" title="浮云计算">
  
  <link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker" rel="stylesheet">
  
  

  
</head>


<body>
  <article class="post 中文" id="article">
    <div class="row">
      <div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2 col-lg-6 col-lg-offset-3">
        <div class="site-header">
          <header>
  <div class="signatures site-title">
    <a href="/">Lirian Su</a>
  </div>
</header>
<div class="row end-xs site-header-right">
  
  <div class="site-header-item">
    <a href="/about" target="_blank">about</a>
  </div>
  
  <div class="site-header-item">
    <a href="https://github.com/LKI" target="_blank">github</a>
  </div>
  
  <div class="site-header-item">
    <a href="https://www.zhihu.com/people/liriansu" target="_blank">zhihu</a>
  </div>
  
  <div class="site-header-item">
    <a href="/index.xml" target="_blank">rss</a>
  </div>
  
</div>
<div class="header-line"></div>

        </div>
        <header class="post-header">
          <h1 class="post-title">毕业五年的报告之技术</h1>
          
          <div class="row post-desc">
            
            <time class="post-header-item" datetime="2020-07-12 23:45:58 CST">
              Written at 2020-07-12 23:45
            </time>
            
            <span class="post-header-item" id="busuanzi_container_page_pv"> Views <span id="busuanzi_value_page_pv" /> </span>
          </div>
          
        </header>

        <div class="post-content markdown-body">
          <p>16年接触了 Web 整套技术栈的我，<br />
决定在这条路上不断攀爬，<br />
直到找到我技术上的天花板。<br />
当时我写了一篇<a href="/backend-skill-tree">《后端工程师技能树》</a>。</p>

<p>现在回过头再看，<br />
我并没有按照叶子节点的顺序去一步步做。<br />
除了系统地学习了解技术知识以外，<br />
我更多是在“明天上线”以及“线上挂了”的血与火的泥泊里扑腾。</p>

<p>这篇就以不同的视角，<br />
记录一下我这几年技术上的感悟吧。<br />
由于讲述的更偏 Web，<br />
所以本篇基本都是以再惠的实际开发为例。</p>

<h2 id="项目-语言与框架">项目、语言与框架</h2>

<p>16年的时候，公司的业务在一个大主站里就可以完全解决了。<br />
这单个项目不仅包括了全部后端代码，<br />
还包括了全部前端代码（不过后来前端就拆出去了）</p>

<p>当时用的是 Python 2.7 + Django 1.8,<br />
不过由于 Python2 在生命的末期，<br />
后来我们就<a href="/py2-to-py3">找了个周末升级到了 Python 3.5</a>。<br />
顺带一提，当时不升 Python 3.6 的原因是 Ubuntu 16 默认带的是 Python 3.5。</p>

<p>Python 是一门非常容易上手的语言，<br />
我进再惠前其实没有认真用过（连 virtualenv 都不知道是什么，只会 print），<br />
但很快就可以开始参与业务开发了。<br />
整个主站在开发周期里，<br />
框架没有大的变动，<br />
基本上是前人怎么写的，后人就怎么写。</p>

<p>当时我在语言上感兴趣的几个点，主要包括：</p>

<ul>
<li>magic method 与元编程：于是我实现了一套根据配置生成接口的逻辑<br /></li>
<li>性能、并发与处理能力：于是我们经常在小黑板上画各类网络架构图<br /></li>
<li>不同框架之间的对比：于是我们内部后面的项目尝试使用了 flask/tornado 等各类框架<br /></li>
<li>关于语言本身的话题：于是我们内部每天都在讨论<a href="https://www.yinwang.org/">垠神@wangyin 的博客</a>（x<br />
<br /></li>
</ul>

<p>后来业务线逐渐开始变多，<br />
我也有机会从零开始搭建一个项目。<br />
因为是从零开始，所以我心中暗想：<br />
“以前很多东西我都是知其然不知其所以然，<br />
这次项目的所有方面我都要完全理解才行。”<br />
于是那个月所有的业余时间我都在读各种文档…</p>

<p>不读不知道，一读吓一跳。<br />
我发现我以前默认的很多习惯用法，<br />
其实都有更佳的实践：</p>

<ul>
<li><p><strong>轻度使用</strong>：<br />
以前项目里会搭配着使用 djangorestframework,<br />
但我们从来都是手写各种序列化类，<br />
并没有使用框架自带的 django model 支持。<br />
而且我们自己实现了一套 schema 验证系统，<br />
既没有用 djangorestframework,<br />
也没有用 marshmellow 这样的库。<br />
（这导致了后面支持 swagger 非常困难）</p></li>

<li><p><strong>缺少检查</strong>：<br />
Python 社区中有非常多的检查工具，<br />
但我们只用到了最基础的 flake8 来验证 PEP8 风格。<br />
我们在合作编程中，<br />
因为每个人 PyCharm 配置的不一样，<br />
解了无数次 import 的冲突。<br />
（更别提还有数组末行加逗号的冲突了）</p></li>

<li><p><strong>版本老旧</strong>：<br />
我们用的很多三方库一直保持着版本更新，<br />
但我们却一直用着旧的版本（更别说语言本身了，f-string 我们也是老后面才用上的）</p></li>
</ul>

<p>这些问题在后面的项目开发中，<br />
我逐个都解决掉了。<br />
轻度使用的问题好说，找一个哥去研究正确的用法然后去优化就行了。<br />
（有时这个优化会涉及几百个文件，所以需要一个 vim 用的溜的哥）<br />
缺少检查也好说，像 flake8/isort/pytest/pylint/yapf/black 我们都尝试使用过，<br />
后面按照项目规模我们开了不同级别的检查，<br />
原则上，项目越大检查越严格。<br />
关于语言与三方库版本的问题，<br />
我每周基本都会保持跟社区的更新，<br />
以人肉 dependency bot 的方式去维护代码。<br />
在解决完这些明显的问题后，<br />
19年我很开心地跟伙伴们感慨过：<br />
“我很有信心说，我们写的这个项目就算放在开源社区也是一流的。”</p>

<p>框架上最终我们还是大规模使用了 Django，<br />
因为 Django 的整套 ORM 实在是对增删改查这样的业务太契合了。<br />
性能上我们后面尝试并最终使用了 gevent，<br />
让整个项目写起来体验一致，<br />
跑起来性能合格。</p>

<p>现在要我实现一个标准的 Python Web 服务的话，我会考虑使用这样的技术组合：</p>

<ul>
<li>使用最新的版本号，比如 Python3.8+/Django3+/Celery4.5+ 等<br /></li>
<li>在 CI 中开启一系列标准检查，比如 flake8/isort/pytest/black<br /></li>
<li>使用 gnumake/pipenv/drf-yasg 这样的工具链<br /></li>
<li>使用 gunicorn+gevent 作为运营环境<br /></li>
<li>在语言的性能问题成为了关键问题时，考虑使用 golang 重写关键部分（不过一般此时都要更大程度上更新架构了）<br />
<br />
<br /></li>
</ul>

<h2 id="平台">平台</h2>

<p>过去几年的技术生涯里，<br />
我最主要跟两个平台在打交道：<br />
一个是云平台 (AWS/Aliyun/Azure)，<br />
另一个是业务平台（微信开放平台）。</p>

<p>业务平台没什么特别好说的，<br />
因为我做的整块业务都是基于微信生态的，<br />
所以对开放平台、小程序、OpenID/UnionID、支付回调这么一套非常熟悉。</p>

<p>最早接触的云平台是 AWS(China)，<br />
我觉得云平台最好的一点是运维扁平化。<br />
招人的时候我会跟候选人说，<br />
我们这个职位从网络、业务、数据到部署、监控都要接触。<br />
而能做到这一点的基础，<br />
就是我们“去运维化”地让大家直接去对接云平台<br />
（有些地方可能会简单包一层）。</p>

<p>最早我们用的是 AWS（国服），<br />
相比于国际服，国服用户缺少了一些非常基础的设施<br />
（比如像 ACM/Route53 等）<br />
导致不论是像 zappa 这种跑 serveless 的库，<br />
还是 AWS EKS 这种更高阶的服务能力都是缺失的。<br />
在18年底我司就从 AWS 切换到了 aliyun。<br />
其实整体的架构没有本质上的差别，<br />
感受上阿里云的服务的确好些，<br />
不过按 @lxkaka 的说法也可以叫：<br />
“他们这个系统假如没地方问的话说不过去啊！”</p>

<p>目前我们使用云平台的姿势包括：</p>

<ul>
<li>最基础的开机器、负载均衡、域名一系列<br /></li>
<li>数据相关的 MySQL/Redis/Mongo/EMR 一套<br /></li>
<li>监控报警日志相关系统<br /></li>
<li>全套托管的 K8S<br />
<br /></li>
</ul>

<p>随着对云平台使用的更加深入，<br />
跟云平台强绑定的技术也会越来越多，<br />
比如像日志系统就基本抛弃了 ELK 拥抱了阿里的日志。<br />
但从成本的视角上看，<br />
对工具的使用减少了冗余的运维需求，<br />
一定程度上是解放了工程师的时间与效能。</p>

<p>现在要我从头开始搭建云平台的基建的话，我会考虑这样的实现组合：</p>

<ul>
<li>拆分 VPC 网段，大部分情况分生产、测试、访客三个网段就可以了（并辅以合适的安全组策略）<br /></li>
<li>以托管的 K8S 服务为核心搭建业务系统，配上配套基建（云盘、日志、监控等）<br /></li>
<li>用 LB/Gateway 约束网络入口、出口，拆分各网段之间流量，尽量减少网络上的损耗<br /></li>
<li>选型时优先考虑云原生功能，如 MySQL/ES/MQ 等<br />
<br />
<br /></li>
</ul>

<h2 id="部署">部署</h2>

<p>在大主站时期，<br />
我们的 Python 服务以 supervisor+virtualenv 裸部署在三种机器上：</p>

<ul>
<li>Web: nginx+uwsgi+django<br /></li>
<li>Worker: celery worker<br /></li>
<li>Cron: celery beat<br />
<br /></li>
</ul>

<p>此时的更新代码是用 fabric 直接连入机器 <code>git pull + supervisorctl restart</code> 二连。</p>

<p>这样的问题是无缝发版（蓝绿部署）是需要自己手动实现，<br />
比如我们最早实现了一套基于 AWS LB 的动态添加、摘除节点的逻辑。<br />
这部分逻辑称不上优雅，<br />
也需要自己维护。<br />
而且这么做对机器环境有着强依赖，<br />
在前文的升级 Python 版本中，<br />
我们也需要一并进行系统级别的升级。</p>

<p>不过后来很快我们就进行了全站的 docker 化，<br />
并有过一段短暂的基于 docker network 的无缝发版实现。<br />
此时的部署换成了 <code>docker pull + docker(compose) restart</code>。<br />
整条技术链路中我们摘掉了 supervisor/fabric/system 相关的依赖。</p>

<p>伴随着平台从 AWS 迁移到 aliyun，<br />
我们大部分服务也上了 K8S。<br />
部署也从上机器部署升级到了 k8s 相关的部署工具链。</p>

<p>大部分情况项目里用的是手写的 <code>envsubst + kubectl</code>，<br />
不过 kubectl 对版本的支持非常有限，<br />
所以很多时候我们也会附带使用 kustomize。<br />
helm chart 而言对业务系统提供了多余的版本控制功能<br />
（我们一般在线上不会同时跑很多个版本，<br />
往往只会保留最新版跟灰度版）。<br />
但 kustomize 也仅在输出部署文件上做的比较好，<br />
在展示部署进度上并没有特别的功能，<br />
而且<a href="https://github.com/kubernetes-sigs/kustomize/issues/1806">很多时候会在项目里漏一大堆的 configmap</a>&hellip;<br />
所以到目前，我们不少项目都使用了 kapp 进行部署。</p>

<p>而在构建上，我们从最早的 Jenkins CI 全线迁移到了 GitLab CI。<br />
除了集成单元测试、体验版自动更新、灰度发布这些核心流程以外，<br />
我们还深度尝试了许多 GitLab CI 提供的工具集成。<br />
比如像 kaniko/minio+artifacts/gitlab+sentry 等系列自动集成自动部署的工具基本我们都用到了。</p>

<p>时至今日，我考虑新起的一个 Python 服务会包括以下的技术组合：</p>

<ul>
<li>核心部署流程基于 K8S，生产测试使用相同的配置，以 namespace 区分不同组的业务<br /></li>
<li>不采用 helm, 而是使用 kubectl+kustomize+kapp 的方式完成部署<br /></li>
<li>以合适的姿势起新三样：<br />

<ul>
<li>对于 HTTP/RESTful 服务, Web 上使用 gunicorn+django (uwsgi 年久失修了)<br /></li>
<li>对于内部的 gRPC 调用服务，使用内部的 djangrpc 实现 (基于 django，支持一套代码起 http+grpc)<br /></li>
<li>对于异步任务，就是简单的 celery 走起<br /></li>
</ul></li>
<li>对于以上提到的服务，部署中考虑完整的向前兼容、按流量/用户的灰度、标准的监控日志报警的搭建<br />
<br />
<br /></li>
</ul>

<h2 id="架构">架构</h2>

<p>早期我们的网络拓扑相对简单，<br />
流量的路线是 <code>外部 ==&gt; aws elb ==&gt; nginx+uwsgi+django(单台机器)</code>，<br />
我们仅在整条链路上做了少数配置，<br />
比如在 aws elb 上配置 https 的处理，<br />
在机器上做了简单的日志收集。</p>

<p>而现在我们的网络拓扑有多种路径，<br />
以其中相对标准的阿里云上托管的 K8S Web 服务为例：<br />
<code>外部 ==&gt; ali slb ==&gt; k8s ingress ==&gt; nginx ==&gt; gunicorn+django</code>.<br />
可以比较发现除了 k8s ingress 层外，<br />
nginx 层也被单独拆分了出来。<br />
这样的网络拓扑我们对其的控制粒度更加精细，<br />
不仅可以在每一层单独处理 IP/流量/日志/行为 等逻辑，<br />
而且每一层也都是可拆卸可更换的。<br />
比如目前我们的集群中，<br />
就有使用到 <code>nginx-ingress-controller</code> 的，<br />
也有使用 <code>kong-ingress-controller</code> 的。</p>

<p>而在整体的服务架构上，<br />
我们拆分了三层的服务。<br />
顶层是 Web 层，这些服务主要对外部提供服务，走的主要是公网流量的 RESTful 调用；<br />
中间是 Service 层，这些服务主要对内部提供服务，走的主要是内网流量的 RESTful/gRPC 调用<br />
（我们正在使用 gRPC 逐步替换内网 RESTful）；<br />
底层是 Tool 层，包括了一系列我们维护的中间件、工具服务或者是包了一层的云原生服务。</p>

<p>以我现在的认识，在一个中型规模的技术团队（100人规模），我会采取这样的架构技术组合：<br />
- 以网络为边界拆分内外部流量，外部使用 RESTful HTTP 调用，内部使用 gRPC 调用<br />
- 在业务合适的情况下，使用比如类似 Kong 这样的技术作为网关，处理鉴权、灰度、分流等系列逻辑<br />
- 内部服务之间不限制选型（前提是做好人员梯度培养），但要划分清晰的服务边界，进行合适的分层<br />
- 区分不同层服务的级别，以定义好稳定性要求、创新余地与网络拓扑</p>

<h2 id="协作">协作</h2>

<p>团队协作的核心，就是人跟人的交流。</p>

<p>因为业务线相对较多，我们基本上是以 two pizza team 的粒度来拆分团队的<br />
（two pizza team 的意思就是点外卖时，两份披萨可以让整个团队吃饱）<br />
每个相对较小的团队会负责数个独立的服务，<br />
组内成员互为 backup、互相学习、共同成长。</p>

<p>最早我们的 git 开发流是基于 commit diff 的，<br />
换句话说只要你的改动是正确的，<br />
那基本就可以合并进主干分支了。<br />
——不过我们很快尝到了苦头（这个很快≈三年）<br />
一些老的代码因为当时的产品也没有留下成建制的 PRD，<br />
而且我们公司做的是B端产品，逻辑有时又巨特么合理的绕，<br />
导致后人在 blame history 时，<br />
经常需要去分析这究竟是 bug 还是 feature。</p>

<p>到目前，我们整个团队（强行被）达成了一致，<br />
使用的是“一个 PR 只有一个 Commit 只做一件事情”的基于 rebase 的协作流，<br />
我们这样产出了接近于线性的完美 git 历史。</p>

<p>而另一方面，关于版本控制我们基于 git tag 使用了内部的小机器人来管理。<br />
因为我们不需要考虑旧版本的兼容维护问题，<br />
所以大部分情况我们用的是日期化的格式 (<code>v2020.07.01</code>)。<br />
基于 git tag 我们又跟 sentry-release/ticket-system 做了一系列的工具链，<br />
包括自动生成版本之间的 changelog，<br />
自动对每个版本的发布内容进行归类分析等。</p>

<p>整套使用 git rebase 开发，使用 git tag 发布的协作机制让我们获益不少。<br />
而为了达到这样的效果，我们在团队内部达成了这样的约定：</p>

<ul>
<li>认知上，项目以 rebase 为开发基础<br />

<ul>
<li>没有什么“我不会用 git”的接口，不会可以学。<br /></li>
<li>个人当然可以喜欢 merge，那请在个人项目里用，团队项目大家统一规范<br /></li>
</ul></li>
<li>行动上，就做到我们设想的那样好<br />

<ul>
<li>每个 PR 只包含一个 Commit，每个 Commit 只修改一类内容<br /></li>
<li>提了 PR 就求 Code Review, Review 了就留评论，评论改完了就合并，不拖泥带水<br /></li>
</ul></li>
<li>工具上，我们需要有个哥来解决协作工具完善的问题<br />

<ul>
<li>我们优化了 Pipeline 的速度，跑完 97% 覆盖率的单元测试+所有检查只要 3 分钟左右<br /></li>
<li>针对线性历史，我们提供了一系列发版、合并、变动检测的机器人助手功能<br />
<br /></li>
</ul></li>
</ul>

<p>除了基于 git 的整套开发流，<br />
我们还共同维护着一整个新手村任务（在以前的文章里有讲过），<br />
而且我们推行的 Buddy 制度会让一个有经验的同学完全手把手地带新人<br />
（不过这个具体要看每个人用心的程度了）</p>

<h2 id="总结">总结</h2>

<p>回过头看，这几年参与的技术讨论、选型、命名、开发、协作、复盘都历历在目。<br />
了解的技术越多，我就越觉得技术世界的广博与好玩。<br />
其实做技术就像玩游戏一样，本质上都是打怪升级穿装备。<br />
本文里讲的，也可能只是我在这世界的一隅，提笔能想起来的一些只言碎语。</p>

<p>但假如我要把整篇文章都删掉，<br />
只能留下一句话。<br />
那我会毫不犹豫地留下这句话：</p>

<p><strong>不会可以学</strong></p>

<p><img src="/assets/u_can_learn.jpg" alt="u-can" /></p>

<p>（未完待续）</p>
        </div>

        
          

          
          <div style="height: 20px;"></div>
        

        



<div class="post-comments">
  <script src="https://utteranc.es/client.js"
          repo="LKI/lki.github.io"
          issue-term="title"
          label="comment"
          theme="github-light"
          crossorigin="anonymous"
          async>
  </script>
</div>


        

<div class="site-footer">
  <div class="site-footer-left">
    <div class="site-footer-item">
      <span id="busuanzi_container_site_pv" style="display:none"> PV: <span id="busuanzi_value_site_pv"/> </span>
    </div>
    <div class="site-footer-item">
      <span id="busuanzi_container_site_uv" style="display:none"> UV: <span id="busuanzi_value_site_uv"/> </span>
    </div>
  </div>

  <div class="site-footer-right">
    
    
    <div class="site-footer-item">
      <a href="/en/">English</a>
    </div>
    
    
  </div>
</div>

      </div>
    </div>
  </article>

  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

</body>

</html>
